import base64
import re
import sys

import requests
from packaging.version import parse as packaging_version_parse
from packaging.specifiers import SpecifierSet


class VulnerabilityChecker:
    header = "Dependency Name | Current Dependency Version | CVE ID | Fix version"
    rows = []

    def __init__(self):
        self.insecure_full_db = self.getr_insecure_full_db()

    @staticmethod
    def getr_insecure_full_db():
        """
        :return: insecure full db in json format. used for the requirements.txt file
        """
        url = "https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json"
        response = requests.get(url)
        if response.status_code == 200 and response != {}:
            return response.json()
        else:
            print(f"CVE db could not be accessed: {response.status_code}")
            sys.exit(2)

    @staticmethod
    def is_vulnerable_version(version, spec_list):
        """
        :param version: given version
        :param spec_list: range of versions that are considered vulnerable
        :return: if the given version is within that range
        """
        for spec in spec_list:
            # packaging_version_parse(version): the current version parsed
            # SpecifierSet(spec): a set of ranges of versions
            if packaging_version_parse(version) in SpecifierSet(spec):
                return True
        return False

    def rcheck_package(self, package_name, version):
        # from insecure full, get the right value for our package
        vulnerabilities = self.insecure_full_db.get(package_name, [])
        for vulnerability in vulnerabilities:
            if self.is_vulnerable_version(version, vulnerability.get("specs", [])):  # version relevant?
                if "cve" in vulnerability:
                    fix_version = self.get_fixed_version(version,
                                                         vulnerability.get('advisory', 'No advisory available'))
                    self.rows.append([
                        package_name, version, vulnerability.get('cve', 'N/A'),
                        fix_version
                    ])

    @staticmethod
    def get_fixed_version(current_version, text: str):
        """
         both of the sources I use does not directly specify a fix version.
         because of that, I use the vulnerability description/advisory and I manipulate it
         to find the fixed version that it specifies. I am aware that this process
         does not provide 100% accurate results.
         each step of the function is explained throughout the code
        :param current_version: version we want to check
        :param text: description/advisory of vulnerability
        :return: fixed version.
        """
        # regex to match version patterns (x.x.x)
        version_pattern = r'\b\d+\.\d+\.\d+\b'
        # find all possible versions in the description
        version_numbers = re.findall(version_pattern, text)
        if version_numbers:
            # convert to tuples of integers to compare later
            version_tuples = []
            for v in version_numbers:
                parts = v.split('.')  # Split the version number string into parts on the dot
                int_parts = [int(part) for part in parts]
                version_tuple = tuple(int_parts)
                version_tuples.append(version_tuple)
            # do the same but for the given version, for comparison later
            parts = current_version.split('.')
            int_parts = [int(part) for part in parts]  # Convert each part to an integer
            current_version_tuple = tuple(int_parts)  # Convert the list of integers into a tuple

            # filter irrelevant versions, those who are before our current one
            possible_fixed_versions = []
            for v in version_tuples:
                if v > current_version_tuple:
                    possible_fixed_versions.append(v)

            if possible_fixed_versions:
                possible_fixed_versions.sort()
                earliest = possible_fixed_versions[0]
                string_parts = [str(part) for part in earliest]
                fixed_version = '.'.join(string_parts)
                return fixed_version

        return "fixed versions not specified"

    def pcheck_package(self, package_name, version):
        """
        :param package_name: name of package to check
        :param version: its version
        :return: all of the vulnerability data of the package's version will be stored in our table
        """
        url = f"https://ossindex.sonatype.org/api/v3/component-report"
        email = "omerbirsh2@gmail.com"
        api_token = "3092c9a457377cf65f438cd74fd6112e19df93aa"
        credentials = base64.b64encode(f"{email}:{api_token}".encode('utf-8')).decode('utf-8')
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': f'Basic {credentials}',
        }
        payload = {
            "coordinates": [f"pkg:npm/{package_name}@{version}"]
        }
        response = requests.post(url, headers=headers, json=payload)
        #  handle case when api will fail
        if "Request rate limit exceeded" in str(response.json()):
            print("Api key is not connected or request rate limit exceeded\n"
                  "cannot continue the process.")
            sys.exit(2)
        data = ""
        if response.status_code == 200:
            data = response.json()[0]['vulnerabilities']  # access the vulnerability key in the json response
        else:
            print(f"Could not retrieve data from the api. HTTP ({response.status_code} status code)")
        if data:
            cve = data[0]['id']
            fix_version = self.get_fixed_version(version, data[0]['description'])
            self.rows.append([
                package_name, version, cve,
                fix_version
            ])

    def print_report(self):
        """
        prints out the table with all the data
        """
        headers = self.header.split(" | ")
        col_widths = []
        if len(VulnerabilityChecker.rows) == 0:
            print("No Cve's found! (:")
            return
        # calculate the maximum width for each column
        for i in range(len(headers)):
            max_width = 0
            for row in self.rows:
                if len(str(row[i])) > max_width:
                    max_width = len(str(row[i]))
            if len(headers[i]) > max_width:
                max_width = len(headers[i])
            col_widths.append(max_width)

        header_row = ''
        for i, header in enumerate(headers):
            header_row += header.ljust(col_widths[i]) + ' | '
        header_row = header_row.rstrip(' | ')  # remove last separator
        print(header_row)

        for row in self.rows:
            row_data = ''
            for i, field in enumerate(row):
                row_data += str(field).ljust(col_widths[i]) + ' | '
            row_data = row_data.rstrip(' | ')  # remove last separator
            print(row_data)
